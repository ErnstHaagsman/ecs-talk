<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Django on ECS</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/eh.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">

				<section class="center">

					<div class="title_card">
						<h1>Deploying a<br>Django Application <br>to Amazon ECS</h1>
						<h2>Ernst Haagsman, JetBrains</h2>
					</div>
				</section>

				<section>
					<h2>About me</h2>
					<ul>
						<li>I live in Munich, Germany</li>
						<li>I'm a Product Marketing Manager for PyCharm</li>
						<li>I like good food</li>
					</ul>
				</section>


				<section>
					<h2>The Plan</h2>
					<ul>
						<li>What's our application?</li>
						<li>Where could we deploy it?</li>
						<li>Docker & Docker-compose</li>
						<li>Simple version on ECS</li>
						<li>Add complexity</li>
						<li>(and use some Python in the progress)</li>
					</ul>
				</section>

				<section class="image">
					<img src="img/django_todo.jpg" alt="The application">
				</section>

				<section>
					<h2>Deployment Alternatives</h2>
					<ul>
						<li>Heroku</li>
						<li>VPS providers (Linode, Digital Ocean)</li>
						<li>Amazon Lightsail</li>
						<li>Amazon EC2</li>
						<li>Azure</li>
						<li>Google Kubernetes Engine</li>
					</ul>

					<aside class="notes">
						<p>Heroku: simple but expensive</p>
						<p>VPS: medium flexibility, API quality may not be great</p>
						<p>Lightsail: VPS with upgrade potential</p>
						<p>EC2: Single box, multiple boxes</p>
						<p>Azure: like AWS, you could have a look to see if it works for you</p>
						<p>GKE: Kubernetes makes some things easy, AWS will also offer K8s soon</p>
					</aside>
				</section>

				<section>
					<div class="title_card">
						<h1>Let's get started!</h1>
					</div>
				</section>

				<section>
					<pre><code class="hljs bash">python manage.py runserver 0.0.0.0:8000</code></pre>
				</section>

				<section>
					<h3>./Dockerfile</h3>
					<pre><code data-trim>
						FROM python:3.6

						WORKDIR /app

						# By copying over requirements first, we make sure that Docker will cache
						# our installed requirements rather than reinstall them on every build
						COPY requirements.txt /app/requirements.txt
						RUN pip install -r requirements.txt

						# Now copy in our code, and run it
						COPY . /app
						EXPOSE 8000
						CMD python manage.py runserver 0.0.0.0:8000
					</code></pre>

					<aside class="notes">
						<ul>
							<li>Containers are basically lightweight VMs</li>
							<li>Provisioned with Dockerfile</li>
							<li>Layers</li>
							<li>Like git, removing a file in a later layer still big</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>./docker-compose.yml</h3>
					<pre><code data-trim>
						version: '2'
						services:
						  web:
							build: .
							ports:
							 - "8000:8000"
							volumes:
							 - .:/app
							links:
							 - db

						  db:
							image: "postgres:9.6"
							ports:
							  - "5432:5432"
							environment:
							  POSTGRES_PASSWORD: hunter2
					</code></pre>

					<aside class="notes">
						<ul>
							<li>Get things from docker hub</li>
							<li>Their docs specify env vars</li>
							<li>Development overrides</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>12 Factor App</h3>
					<ul>
						<li>Dev/prod parity</li>
						<li>Store config in the environment</li>
						<li>And more</li>
					</ul>

					<aside class="notes">
						<a href="12factor.net">The Twelve Factors</a>
					</aside>
				</section>

				<section>
					<h3>Running locally</h3>
					<pre><code data-trim>
						docker-compose up --build
					</code></pre>
				</section>

				<section class="image">
					<video data-autoplay src="img/compose_cli_build.mp4"></video>
				</section>

				<section class="image">
					<img src="img/compose_pycharm.jpg" alt="Configuring Docker Compose in PyCharm">
				</section>

				<section class="center">
					<h2>Ready to go?</h2>
					<p class="fragment">Not yet :(</p>

					<aside class="notes">
						<p>We're still using Django's built-in server</p>
						<p>Switch to Gunicorn (or uwsgi, or anything else)</p>
					</aside>
				</section>

				<section>
					<h2>Switch to Gunicorn</h2>
					<pre><code data-trim>
						pip install gunicorn
						gunicorn --bind 0.0.0.0:8000 djangodocker.wsgi
					</code></pre>

					<aside class="notes">
						Just add gunicorn to requirements.txt, and change
						dockerfile (next slide)
					</aside>
				</section>

				<section>
					<h3>./Dockerfile</h3>
					<pre><code data-trim data-noescape>
						FROM python:3.6

						WORKDIR /app

						# By copying over requirements first, we make sure that Docker will cache
						# our installed requirements rather than reinstall them on every build
						COPY requirements.txt /app/requirements.txt
						RUN pip install -r requirements.txt

						# Now copy in our code, and run it
						COPY . /app
						EXPOSE 8000
						<del>CMD python manage.py runserver 0.0.0.0:8000</del>
						<mark>CMD gunicorn --bind 0.0.0.0:8000 djangodocker.wsgi</mark>
					</code></pre>

					<aside class="notes">
						<ul>
							<li>What about static files?</li>
						</ul>
					</aside>
				</section>

				<section>
					<h3>Nginx</h3>
					<p>Serve static files</p>
					<p>Reverse proxy Django</p>
				</section>

				<section>
					<h3>Nginx on same container?</h3>
					<ul>
						<li>Load balancing</li>
						<li>Unix socket</li>
						<li>Is the load uneven?</li>
					</ul>

					<aside class="notes">
						Separate is difficult because you'd need to
						load balance twice.
						Same container allows use of unix socket.
						Argument for separate would be highly unequal
						load.
					</aside>
				</section>

				<section>
					<h3>Add nginx</h3>
					<pre><code data-trim data-noescape>
						FROM python:3.6<mark>-jessie</mark>

						WORKDIR /app

						<mark>RUN apt-get update && apt-get install --no-install-recommends -y nginx \
							&& rm -rf /var/lib/apt/lists/*</mark>

						# By copying over requirements first, we make sure that Docker will cache
						# our installed requirements rather than reinstall them on every build
						COPY requirements.txt /app/requirements.txt
						RUN pip install -r requirements.txt

						<mark>COPY nginx.conf /etc/nginx/nginx.conf
						RUN python -u manage.py collectstatic</mark>

						# Now copy in our code, and run it
						COPY . /app
						EXPOSE 8000
						<mark>CMD nginx && gunicorn --bind unix:/tmp/gunicorn.sock djangodocker.wsgi</mark>
					</code></pre>

					<aside class="notes">
						Complex apt statement, because we need to clean
						up after ourselves (or the image gets YUGE)

						We need the collectstatic because we now need to
						put static files in the right place for nginx
					</aside>
				</section>

				<section>
					<h3>nginx.conf</h3>
					<pre><code data-trim>
						http {

							upstream app_server {
								# fail_timeout=0 means we always retry an upstream even if it failed
								# to return a good HTTP response for UNIX domain socket setups
								server unix:/tmp/gunicorn.sock fail_timeout=0;
							}

							server {
								listen 8000 deferred;

								location /static/ {
								  root /var/www;
								}

								location / {
								  proxy_pass http://app_server;
								}
							}
						}
					</code></pre>

					<aside class="notes">
						This is an excerpt. See the repo for more.
					</aside>
				</section>

				<section>
					<h3>settings.py</h3>
					<pre><code data-trim>
						SECRET_KEY = os.environ['SECRET_KEY']

						_debug = os.environ.get('DEBUG', '0')
						DEBUG = _debug == '1'  # only switch on debug if the DEBUG env var is '1'

						ALLOWED_HOSTS = [os.environ['HOST']]

						DATABASES = {
							'default': {
								'ENGINE': 'django.db.backends.postgresql',
								'NAME': os.environ['DB_NAME'],
								'USER': os.environ['DB_USER'],
								'PASSWORD': os.environ['DB_PASSWORD'],
								'HOST': os.environ['DB_HOST']
							}
						}

						STATIC_ROOT = '/var/www/static'
					</code></pre>

					<aside class="notes">
						os.environ will raise KeyError if an env var is
						unset. What is the problem here?
						Remember collectstatic?
					</aside>
				</section>

				<section>
					<h3>Dockerfile</h3>
					<pre><code data-trim data-noescape>
						...

						COPY requirements.txt /app/requirements.txt
						RUN pip install -r requirements.txt

						ENV SECRET_KEY=INSECURE_PLACEHOLDER \
							HOST='*' \
							DB_HOST='PLACEHOLDER' \
							DB_NAME='PLACEHOLDER' \
							DB_USER='PLACEHOLDER' \
							DB_PASSWORD='PLACEHOLDER'

						...
					</code></pre>
				</section>

				<section class="center">
					<h3>Not shown:</h3>
					<p>Running as a non-root user</p>

					<aside class="notes">
						See the repo.

						Installing sudo, adding a user, lots of
						mkdir and chown, giving the user the right
						to start nginx as sudo.
					</aside>
				</section>

				<section class="center">
					<div class="title_card">
						<h1>Amazon ECS</h1>
					</div>
				</section>

				<section>
					<h3>Concepts</h3>
					<ul>
						<li>Elastic Container Registry</li>
						<li>Task Definition</li>
						<li>Service</li>
						<li>Cluster</li>
					</ul>
				</section>

				<section>
					<h3>Architectural Questions</h3>
					<ul>
						<li>Database</li>
						<li>Load Balancing</li>
					</ul>

					<aside class="notes">
						You could host both services in their own container, for load balancing even somewhat easy
						(no need to solve any persistency issues). For database considerably harder (container hosts
						are essentially ephemeral). We'll use Amazon provided versions of both.
					</aside>
				</section>

				<section>
					<h3>Prerequisites</h3>
					<ul>
						<li>AWS Account</li>
						<li>Key pair configured in AWS region</li>
					</ul>
				</section>

				<section class="image">
					<img src="img/aws_service_overview.png" alt="Overview of services">
				</section>

				<section class="image">
					<img src="img/ecs_architecture.png" alt="Architecture overview">

					<aside class="notes">
						Grey boxes represent containers. ECS handles both scaling up and down the ECS instances,
						and the placement of containers on those instances.

						Next: Set up cluster
					</aside>
				</section>

				<section class="image">
					<img src="img/ecs_cluster_1.png" alt="Configuring an ECS cluster">
				</section>

				<section class="image">
					<img src="img/ecs_cluster_2.png" alt="Configuring an ECS cluster">

					<aside class="notes">
						<ul>
							<li>Instance type</li>
							<li>Instance count</li>
							<li>Key pair</li>
						</ul>

						<p>Setting up the cluster will create a VPC</p>
						<p>Next: Container Registry</p>
					</aside>
				</section>

				<section class="image">
					<img src="img/ecr_create_repo.png" alt="Create a repository">
				</section>

				<section class="image">
					<img src="img/ecr_push_instructions.png" alt="How to push an image to ECR">

					<aside class="notes">
						Next: RDS
					</aside>
				</section>

				<section class="image">
					<img src="img/rds_choose_engine.png" alt="RDS">

					<aside class="notes">
						Next: Test or Prod choice
					</aside>
				</section>

				<section class="image">
					<img src="img/rds_test_or_prod.png" alt="RDS options">
				</section>

				<section class="image">
					<img src="img/rds_settings.png" alt="Configure RDS">
				</section>
				
				<section class="image">
					<img src="img/rds_complete.png" alt="RDS instance running">

					<aside class="notes">
						Note the endpoint is now available

						<p>Next: Security Groups</p>
					</aside>
				</section>

				<section class="image">
					<img src="img/vpc_security_groups.png" alt="Security group overview">
				</section>

				<section class="image">
					<img src="img/vpc_sg_rds.png" alt="Adding the inbound rule for the DB">

					<aside class="notes">
						Next: Migrate task definition
					</aside>
				</section>

				<section class="image">
					<img src="img/ecs_task_definitions_empty.png" alt="Task definition empty overview">
				</section>

				<section class="image">
					<img src="img/ecs_task_definitions_add_container_1.png" alt="Add task definition">
				</section>

				<section class="image">
					<img src="img/ecs_task_definitions_add_container_2.png" alt="Add task definition">

					<aside class="notes">
						Make sure to comma-separate parts of the command

						How about seeing the output? Configure logs!
					</aside>
				</section>

				<section class="image">
					<img src="img/ecs_task_definitions_add_container_3.png" alt="Configure logging for ECS task">
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				controls: false,
				width: 1920,
				height: 1080,
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
